# CSC120-FinalProject

## Deliverables:
 - Your final codebase
 - Your revised annotated architecture diagram
 - Design justification (including a brief discussion of at least one alternative you considered)
 - A map of your game's layout (if applicable)
 - `cheatsheet.md`
 - Completed `rubric.md`
  
## Reflection

I was excited to do this project because I always enjoy games, but it did seem a bit daunting at first. I started by planning everything out, drafting the architecture diagram, implementing features that I felt like I already understood, and so on. Once that was done, I tried to make the game loop run with just one room (I figured it would be easier to expand it after). Then I basically just kept testing, revising, and adding on until I felt like it was complete! One thing that helped a lot was learning about "case switch" in Java, which I utilized to handle user input. I think that made it much easier (both to implement and to understand) than having many if-else statements. I'm pretty happy with how my project has turned out, though it could possibly use a bit of consolidation in some areas? Also, if I had more time, I might like to try adding directions to let players move around the map more freely. What I have now works, but cardinal directions or some sort of coordinate system might be nice in terms of making the game feel more immersive. During the first code review in class, Rya asked me a bit about my game loop, what I was planning on having it contain, why I wanted it to be a loop, etc. and I think that talking about that helped me wrap my head around how I actually intended the game to be played, and gave me inspiration to try figuring the parts that I didn't yet understand. Along with Bebe, we also brainstormed about how to keep track of the game "state," which was helpful because that was something I was having trouble figuring out as well. If I could talk to my past self, I think the most helpful piece of advice I could give would be prioritize modularization! In other words, break down the program into many smaller tasks, each handled by seperate methods, rather than adding everything into one method or one loop. Somehow, adding more actually makes everything much simpler.

## Design Justification
For this project, I implemented a text-based escape room game where players navigate a mysterious building, finding keys and other items that allow them to eventually make it outside. In the beginning, I thought I could add everything in Game.java to one play() method, as I was initialy able to make it work that way. However, after realizing how many elements I would need for the game to run as I intended, it became apparent that I would need to divide the content of this one method into multiple seperate methods. Though it was easier to implement a single method at first, it was harder to work with when I wanted to add new features, objects, and so on. Also, when it comes to debugging, it's definitely easier to test code that's divided between many methods, rather than all jammed together into one. Not to mention, readability is much improved. All in all, a modular design definitely worked best in this case, allowing for more flexibility and making the design more extensible. While a simple game might be able to run with fewer classes or methods, mine definitely required that I divided my code between many classes, each containing numerous methods of their own.